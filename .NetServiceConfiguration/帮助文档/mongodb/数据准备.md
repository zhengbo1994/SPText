# 数据准备

##### Mongodb基本操作

~~~shell
查询数据库
show databases
切换数据库
use test
查询当前数据库下面的集合
show  collections
创建集合
db.createCollection("集合名称")
删除集合
db.集合名称.drop()
删除数据库
db.dropDatabase() //首先要通过use切换到当前的数据库
~~~

##### Mongodb增删改查(CURD)

id 系统会自动加一个

时间戳+机器码 生成

###### 增（insert）

~~~shell
新增一条
db.userinfo.insert({name:"贾宝玉",age:25,gander:"男",address:'贾府'})
新增多条
db.userinfo.insert([{name:"贾宝玉",age:25,gander:"男",address:'贾府'}
,{name:"林黛玉",age:16,gander:"女",address:'林府'}])
可不可以快速插入10条数据
for(var i=1;i<=10;i++)
{
 db.userinfo.insert({name:"clay"+i,age:i})
 } 

~~~

###### 查（find）

~~~shell
查询所有的数据
db.集合名称.find({})
查询top条数
db.集合名称.find({}).limit(条数)
条件查询
 db.userinfo.find({name:"clay1",age:1},{name:1,_id:0})
~~~

###### 排序&分页

~~~shell
db.c1.insert({_id:1,name:"a",sex:1,age:1})
db.c1.insert({_id:2,name:"a",sex:1,age:2})
db.c1.insert({_id:3,name:"b",sex:2,age:3})
db.c1.insert({_id:4,name:"c",sex:2,age:4})
db.c1.insert({_id:5,name:"d",sex:2,age:5})

db.c1.find()
正序
db.c1.find({}).sort({age:1})
降序
 db.c1.find({}).sort({age:-1})
 分页查询 跳过两条查询两条
 db.c1.find({}).sort({age:1}).skip(2).limit(2) 
 
~~~

######    运算符

| 运算符 | 作用     |
| :----: | :------- |
|  $gt   | 大于     |
|  $gte  | 大于等于 |
|  $lt   | 小于     |
|  $lte  | 小于等于 |
|  $ne   | 不等于   |
|  $in   | in       |
|  $nin  | not in   |

~~~shell
//年龄大于1
db.c1.find({age:{$gt:1}})
//年龄是 3,4,5的
db.c1.find({age:{$in:[3,4,5]}})
~~~

###### 改（update）

db.集合名.update（条件， 新数据）
					  {修改器: {键:值}}

| 修改器  | 作用     |
| :-----: | :------- |
|  $inc   | 递增     |
| $rename | 重命名列 |
|  $set   | 修改列值 |
| $unset  | 删除列   |

~~~shell
 准备数据
 
 db.c1.insert({name:"8888",age:1,addr:'address',flag:true})
  db.c1.update({name:"8888"}, {name:"99"})
 db.c1.update({name:"8888"}, 
 {
  $set:{name: "zs44"},
  $inc:{age:10},
  $rename:{addr:"address"} ,
  $unset:{flag:""}
   }
 )
 db.c1.find({name:"zs44"})
 
 
~~~



###### 删（delete）

```js
//全部移除
db.userinfo.deleteMany({})
db.userinfo.deleteMany({age:1})
```



##### 聚合查询

顾名思义就是把数据聚起来，然后统计

###### 语法

````
db.集合名称.aggregate([
    {管道:{表达式}}
     ....
])
````

###### 常用管道

```
$group 将集合中的文档分组，用于统计结果
$match 过滤数据，只要输出符合条件的文档
$sort  聚合数据进一步排序
$skip  跳过指定文档数
$limit 限制集合数据返回文档数
....
```

###### 常用表达式

```
$sum  总和  $sum:1同count表示统计
$avg  平均
$min  最小值
$max  最大值
...
```





###### 准备

````
use test4
db.c1.insert({_id:1,name:"a",sex:1,age:1})
db.c1.insert({_id:2,name:"a",sex:1,age:2})
db.c1.insert({_id:3,name:"b",sex:2,age:3})
db.c1.insert({_id:4,name:"c",sex:2,age:4})
db.c1.insert({_id:5,name:"d",sex:2,age:5})
````



###### 练习

- 统计男生、女生的总年龄

> ```
> db.c1.aggregate([
> {
> 	$group:{
> _id: "$sex",
> rs: {$sum: "$age"}
> 	}
> }
> ])
> ```

- 统计男生、女生的总人数

> ```
> db.c1.aggregate([
> {
> 	$group:{
> _id: "$sex",
> rs: {$sum:1}
> 	}
> }
> ])
> ```

- 求学生总数和平均年龄

> ```
> db.c1.aggregate([
> {
> 	$group:{
> _id: null,
> total_num: {$sum:1},
> total_avg: {$avg: "$age"}
> 	}
> }
> ])
> ```

- 查询男生、女生人数，按人数升序

> ```
> db.c1.aggregate([
> {$group:{_id: "$sex",rs: {$sum: 1}}},
> {$sort:{rs: -1}}
> ])
> ```

##### 



# 自增id

```javascript
#创建序列
db.counters.insert({_id:"productid",sequence_value:0})
```

## 创建 Javascript 函数

现在，我们创建函数 getNextSequenceValue 来作为序列名的输入， 指定的序列会自动增长 1 并返回最新序列值。在本文的实例中序列名为 productid 。

```
>function getNextSequenceValue(sequenceName){
   var sequenceDocument = db.counters.findAndModify(
      {
         query:{_id: sequenceName },
         update: {$inc:{sequence_value:1}},
         "new":true
      });
   return sequenceDocument.sequence_value;
}
```

------

## 使用 Javascript 函数

接下来我们将使用 getNextSequenceValue 函数创建一个新的文档， 并设置文档 _id 自动为返回的序列值：

```
>db.products.insert({
   "_id":getNextSequenceValue("productid"),
   "product_name":"Apple iPhone",
   "category":"mobiles"})

>db.products.insert({
   "_id":getNextSequenceValue("productid"),
   "product_name":"Samsung S3",
   "category":"mobiles"})
```

就如你所看到的，我们使用 getNextSequenceValue 函数来设置 _id 字段。

为了验证函数是否有效，我们可以使用以下命令读取文档：

```
>db.products.find()
```

以上命令将返回以下结果，我们发现 _id 字段是自增长的：

```javascript
{ "_id" : 1, "product_name" : "Apple iPhone", "category" : "mobiles"}

{ "_id" : 2, "product_name" : "Samsung S3", "category" : "mobiles" }
```



# 事务

~~~shell
use test
db.createCollection("userinfo")
// 连接一个会话
s=db.getMongo().startSession()
// 开启事务
s.startTransaction()
// 操作
s.getDatabase("test").userinfo.insert({name:"a"})
// 提交成功 ,.如果这边不执行,则以上都不会执行
s.commitTransaction() 
~~~

# 数据失效机制



mongodb失效的机制大概是这样的

 为集合创建一个indexes（索引）

​     

db.testCollection.ensureIndex( { "Date": 1 }, { expireAfterSeconds: 10 } )

然后确保每次插入数据的时候有该列,mongodb将会自动为你删除该列
        db.testCollection.insert({"Date" : new Date(),"name":"zs","age":18})

设置的失效列必须为索引并且为日期格式 



